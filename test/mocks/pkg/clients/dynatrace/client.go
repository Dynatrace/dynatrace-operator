// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"io"

	"github.com/Dynatrace/dynatrace-operator/pkg/api/latest/dynakube/logmonitoring"
	"github.com/Dynatrace/dynatrace-operator/pkg/clients/dynatrace"
	mock "github.com/stretchr/testify/mock"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// CreateLogMonitoringSetting provides a mock function for the type Client
func (_mock *Client) CreateLogMonitoringSetting(ctx context.Context, scope string, clusterName string, ingestRuleMatchers []logmonitoring.IngestRuleMatchers) (string, error) {
	ret := _mock.Called(ctx, scope, clusterName, ingestRuleMatchers)

	if len(ret) == 0 {
		panic("no return value specified for CreateLogMonitoringSetting")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, []logmonitoring.IngestRuleMatchers) (string, error)); ok {
		return returnFunc(ctx, scope, clusterName, ingestRuleMatchers)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, []logmonitoring.IngestRuleMatchers) string); ok {
		r0 = returnFunc(ctx, scope, clusterName, ingestRuleMatchers)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, []logmonitoring.IngestRuleMatchers) error); ok {
		r1 = returnFunc(ctx, scope, clusterName, ingestRuleMatchers)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateLogMonitoringSetting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogMonitoringSetting'
type Client_CreateLogMonitoringSetting_Call struct {
	*mock.Call
}

// CreateLogMonitoringSetting is a helper method to define mock.On call
//   - ctx context.Context
//   - scope string
//   - clusterName string
//   - ingestRuleMatchers []logmonitoring.IngestRuleMatchers
func (_e *Client_Expecter) CreateLogMonitoringSetting(ctx interface{}, scope interface{}, clusterName interface{}, ingestRuleMatchers interface{}) *Client_CreateLogMonitoringSetting_Call {
	return &Client_CreateLogMonitoringSetting_Call{Call: _e.mock.On("CreateLogMonitoringSetting", ctx, scope, clusterName, ingestRuleMatchers)}
}

func (_c *Client_CreateLogMonitoringSetting_Call) Run(run func(ctx context.Context, scope string, clusterName string, ingestRuleMatchers []logmonitoring.IngestRuleMatchers)) *Client_CreateLogMonitoringSetting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []logmonitoring.IngestRuleMatchers
		if args[3] != nil {
			arg3 = args[3].([]logmonitoring.IngestRuleMatchers)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Client_CreateLogMonitoringSetting_Call) Return(s string, err error) *Client_CreateLogMonitoringSetting_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CreateLogMonitoringSetting_Call) RunAndReturn(run func(ctx context.Context, scope string, clusterName string, ingestRuleMatchers []logmonitoring.IngestRuleMatchers) (string, error)) *Client_CreateLogMonitoringSetting_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateKubernetesAppSetting provides a mock function for the type Client
func (_mock *Client) CreateOrUpdateKubernetesAppSetting(ctx context.Context, scope string) (string, error) {
	ret := _mock.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateKubernetesAppSetting")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, scope)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, scope)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateOrUpdateKubernetesAppSetting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateKubernetesAppSetting'
type Client_CreateOrUpdateKubernetesAppSetting_Call struct {
	*mock.Call
}

// CreateOrUpdateKubernetesAppSetting is a helper method to define mock.On call
//   - ctx context.Context
//   - scope string
func (_e *Client_Expecter) CreateOrUpdateKubernetesAppSetting(ctx interface{}, scope interface{}) *Client_CreateOrUpdateKubernetesAppSetting_Call {
	return &Client_CreateOrUpdateKubernetesAppSetting_Call{Call: _e.mock.On("CreateOrUpdateKubernetesAppSetting", ctx, scope)}
}

func (_c *Client_CreateOrUpdateKubernetesAppSetting_Call) Run(run func(ctx context.Context, scope string)) *Client_CreateOrUpdateKubernetesAppSetting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_CreateOrUpdateKubernetesAppSetting_Call) Return(s string, err error) *Client_CreateOrUpdateKubernetesAppSetting_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CreateOrUpdateKubernetesAppSetting_Call) RunAndReturn(run func(ctx context.Context, scope string) (string, error)) *Client_CreateOrUpdateKubernetesAppSetting_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateKubernetesSetting provides a mock function for the type Client
func (_mock *Client) CreateOrUpdateKubernetesSetting(ctx context.Context, name string, kubeSystemUUID string, scope string) (string, error) {
	ret := _mock.Called(ctx, name, kubeSystemUUID, scope)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateKubernetesSetting")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return returnFunc(ctx, name, kubeSystemUUID, scope)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = returnFunc(ctx, name, kubeSystemUUID, scope)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, name, kubeSystemUUID, scope)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateOrUpdateKubernetesSetting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateKubernetesSetting'
type Client_CreateOrUpdateKubernetesSetting_Call struct {
	*mock.Call
}

// CreateOrUpdateKubernetesSetting is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - kubeSystemUUID string
//   - scope string
func (_e *Client_Expecter) CreateOrUpdateKubernetesSetting(ctx interface{}, name interface{}, kubeSystemUUID interface{}, scope interface{}) *Client_CreateOrUpdateKubernetesSetting_Call {
	return &Client_CreateOrUpdateKubernetesSetting_Call{Call: _e.mock.On("CreateOrUpdateKubernetesSetting", ctx, name, kubeSystemUUID, scope)}
}

func (_c *Client_CreateOrUpdateKubernetesSetting_Call) Run(run func(ctx context.Context, name string, kubeSystemUUID string, scope string)) *Client_CreateOrUpdateKubernetesSetting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Client_CreateOrUpdateKubernetesSetting_Call) Return(s string, err error) *Client_CreateOrUpdateKubernetesSetting_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_CreateOrUpdateKubernetesSetting_Call) RunAndReturn(run func(ctx context.Context, name string, kubeSystemUUID string, scope string) (string, error)) *Client_CreateOrUpdateKubernetesSetting_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveGateAuthToken provides a mock function for the type Client
func (_mock *Client) GetActiveGateAuthToken(ctx context.Context, dynakubeName string) (*dynatrace.ActiveGateAuthTokenInfo, error) {
	ret := _mock.Called(ctx, dynakubeName)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveGateAuthToken")
	}

	var r0 *dynatrace.ActiveGateAuthTokenInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*dynatrace.ActiveGateAuthTokenInfo, error)); ok {
		return returnFunc(ctx, dynakubeName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *dynatrace.ActiveGateAuthTokenInfo); ok {
		r0 = returnFunc(ctx, dynakubeName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dynatrace.ActiveGateAuthTokenInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, dynakubeName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetActiveGateAuthToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveGateAuthToken'
type Client_GetActiveGateAuthToken_Call struct {
	*mock.Call
}

// GetActiveGateAuthToken is a helper method to define mock.On call
//   - ctx context.Context
//   - dynakubeName string
func (_e *Client_Expecter) GetActiveGateAuthToken(ctx interface{}, dynakubeName interface{}) *Client_GetActiveGateAuthToken_Call {
	return &Client_GetActiveGateAuthToken_Call{Call: _e.mock.On("GetActiveGateAuthToken", ctx, dynakubeName)}
}

func (_c *Client_GetActiveGateAuthToken_Call) Run(run func(ctx context.Context, dynakubeName string)) *Client_GetActiveGateAuthToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetActiveGateAuthToken_Call) Return(activeGateAuthTokenInfo *dynatrace.ActiveGateAuthTokenInfo, err error) *Client_GetActiveGateAuthToken_Call {
	_c.Call.Return(activeGateAuthTokenInfo, err)
	return _c
}

func (_c *Client_GetActiveGateAuthToken_Call) RunAndReturn(run func(ctx context.Context, dynakubeName string) (*dynatrace.ActiveGateAuthTokenInfo, error)) *Client_GetActiveGateAuthToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveGateConnectionInfo provides a mock function for the type Client
func (_mock *Client) GetActiveGateConnectionInfo(ctx context.Context) (dynatrace.ActiveGateConnectionInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveGateConnectionInfo")
	}

	var r0 dynatrace.ActiveGateConnectionInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (dynatrace.ActiveGateConnectionInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) dynatrace.ActiveGateConnectionInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(dynatrace.ActiveGateConnectionInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetActiveGateConnectionInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveGateConnectionInfo'
type Client_GetActiveGateConnectionInfo_Call struct {
	*mock.Call
}

// GetActiveGateConnectionInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetActiveGateConnectionInfo(ctx interface{}) *Client_GetActiveGateConnectionInfo_Call {
	return &Client_GetActiveGateConnectionInfo_Call{Call: _e.mock.On("GetActiveGateConnectionInfo", ctx)}
}

func (_c *Client_GetActiveGateConnectionInfo_Call) Run(run func(ctx context.Context)) *Client_GetActiveGateConnectionInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetActiveGateConnectionInfo_Call) Return(activeGateConnectionInfo dynatrace.ActiveGateConnectionInfo, err error) *Client_GetActiveGateConnectionInfo_Call {
	_c.Call.Return(activeGateConnectionInfo, err)
	return _c
}

func (_c *Client_GetActiveGateConnectionInfo_Call) RunAndReturn(run func(ctx context.Context) (dynatrace.ActiveGateConnectionInfo, error)) *Client_GetActiveGateConnectionInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetAgent provides a mock function for the type Client
func (_mock *Client) GetAgent(ctx context.Context, os string, installerType string, flavor string, arch string, version string, technologies []string, skipMetadata bool, writer io.Writer) error {
	ret := _mock.Called(ctx, os, installerType, flavor, arch, version, technologies, skipMetadata, writer)

	if len(ret) == 0 {
		panic("no return value specified for GetAgent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, []string, bool, io.Writer) error); ok {
		r0 = returnFunc(ctx, os, installerType, flavor, arch, version, technologies, skipMetadata, writer)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_GetAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAgent'
type Client_GetAgent_Call struct {
	*mock.Call
}

// GetAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - os string
//   - installerType string
//   - flavor string
//   - arch string
//   - version string
//   - technologies []string
//   - skipMetadata bool
//   - writer io.Writer
func (_e *Client_Expecter) GetAgent(ctx interface{}, os interface{}, installerType interface{}, flavor interface{}, arch interface{}, version interface{}, technologies interface{}, skipMetadata interface{}, writer interface{}) *Client_GetAgent_Call {
	return &Client_GetAgent_Call{Call: _e.mock.On("GetAgent", ctx, os, installerType, flavor, arch, version, technologies, skipMetadata, writer)}
}

func (_c *Client_GetAgent_Call) Run(run func(ctx context.Context, os string, installerType string, flavor string, arch string, version string, technologies []string, skipMetadata bool, writer io.Writer)) *Client_GetAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		var arg6 []string
		if args[6] != nil {
			arg6 = args[6].([]string)
		}
		var arg7 bool
		if args[7] != nil {
			arg7 = args[7].(bool)
		}
		var arg8 io.Writer
		if args[8] != nil {
			arg8 = args[8].(io.Writer)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
		)
	})
	return _c
}

func (_c *Client_GetAgent_Call) Return(err error) *Client_GetAgent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_GetAgent_Call) RunAndReturn(run func(ctx context.Context, os string, installerType string, flavor string, arch string, version string, technologies []string, skipMetadata bool, writer io.Writer) error) *Client_GetAgent_Call {
	_c.Call.Return(run)
	return _c
}

// GetAgentVersions provides a mock function for the type Client
func (_mock *Client) GetAgentVersions(ctx context.Context, os string, installerType string, flavor string) ([]string, error) {
	ret := _mock.Called(ctx, os, installerType, flavor)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentVersions")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) ([]string, error)); ok {
		return returnFunc(ctx, os, installerType, flavor)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) []string); ok {
		r0 = returnFunc(ctx, os, installerType, flavor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, os, installerType, flavor)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetAgentVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAgentVersions'
type Client_GetAgentVersions_Call struct {
	*mock.Call
}

// GetAgentVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - os string
//   - installerType string
//   - flavor string
func (_e *Client_Expecter) GetAgentVersions(ctx interface{}, os interface{}, installerType interface{}, flavor interface{}) *Client_GetAgentVersions_Call {
	return &Client_GetAgentVersions_Call{Call: _e.mock.On("GetAgentVersions", ctx, os, installerType, flavor)}
}

func (_c *Client_GetAgentVersions_Call) Run(run func(ctx context.Context, os string, installerType string, flavor string)) *Client_GetAgentVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Client_GetAgentVersions_Call) Return(strings []string, err error) *Client_GetAgentVersions_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Client_GetAgentVersions_Call) RunAndReturn(run func(ctx context.Context, os string, installerType string, flavor string) ([]string, error)) *Client_GetAgentVersions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAgentViaInstallerURL provides a mock function for the type Client
func (_mock *Client) GetAgentViaInstallerURL(ctx context.Context, url string, writer io.Writer) error {
	ret := _mock.Called(ctx, url, writer)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentViaInstallerURL")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, io.Writer) error); ok {
		r0 = returnFunc(ctx, url, writer)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_GetAgentViaInstallerURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAgentViaInstallerURL'
type Client_GetAgentViaInstallerURL_Call struct {
	*mock.Call
}

// GetAgentViaInstallerURL is a helper method to define mock.On call
//   - ctx context.Context
//   - url string
//   - writer io.Writer
func (_e *Client_Expecter) GetAgentViaInstallerURL(ctx interface{}, url interface{}, writer interface{}) *Client_GetAgentViaInstallerURL_Call {
	return &Client_GetAgentViaInstallerURL_Call{Call: _e.mock.On("GetAgentViaInstallerURL", ctx, url, writer)}
}

func (_c *Client_GetAgentViaInstallerURL_Call) Run(run func(ctx context.Context, url string, writer io.Writer)) *Client_GetAgentViaInstallerURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 io.Writer
		if args[2] != nil {
			arg2 = args[2].(io.Writer)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_GetAgentViaInstallerURL_Call) Return(err error) *Client_GetAgentViaInstallerURL_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_GetAgentViaInstallerURL_Call) RunAndReturn(run func(ctx context.Context, url string, writer io.Writer) error) *Client_GetAgentViaInstallerURL_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommunicationHostForClient provides a mock function for the type Client
func (_mock *Client) GetCommunicationHostForClient() (dynatrace.CommunicationHost, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCommunicationHostForClient")
	}

	var r0 dynatrace.CommunicationHost
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (dynatrace.CommunicationHost, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() dynatrace.CommunicationHost); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(dynatrace.CommunicationHost)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetCommunicationHostForClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommunicationHostForClient'
type Client_GetCommunicationHostForClient_Call struct {
	*mock.Call
}

// GetCommunicationHostForClient is a helper method to define mock.On call
func (_e *Client_Expecter) GetCommunicationHostForClient() *Client_GetCommunicationHostForClient_Call {
	return &Client_GetCommunicationHostForClient_Call{Call: _e.mock.On("GetCommunicationHostForClient")}
}

func (_c *Client_GetCommunicationHostForClient_Call) Run(run func()) *Client_GetCommunicationHostForClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_GetCommunicationHostForClient_Call) Return(communicationHost dynatrace.CommunicationHost, err error) *Client_GetCommunicationHostForClient_Call {
	_c.Call.Return(communicationHost, err)
	return _c
}

func (_c *Client_GetCommunicationHostForClient_Call) RunAndReturn(run func() (dynatrace.CommunicationHost, error)) *Client_GetCommunicationHostForClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntityIDForIP provides a mock function for the type Client
func (_mock *Client) GetEntityIDForIP(ctx context.Context, ip string) (string, error) {
	ret := _mock.Called(ctx, ip)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityIDForIP")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, ip)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, ip)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ip)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetEntityIDForIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntityIDForIP'
type Client_GetEntityIDForIP_Call struct {
	*mock.Call
}

// GetEntityIDForIP is a helper method to define mock.On call
//   - ctx context.Context
//   - ip string
func (_e *Client_Expecter) GetEntityIDForIP(ctx interface{}, ip interface{}) *Client_GetEntityIDForIP_Call {
	return &Client_GetEntityIDForIP_Call{Call: _e.mock.On("GetEntityIDForIP", ctx, ip)}
}

func (_c *Client_GetEntityIDForIP_Call) Run(run func(ctx context.Context, ip string)) *Client_GetEntityIDForIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetEntityIDForIP_Call) Return(s string, err error) *Client_GetEntityIDForIP_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_GetEntityIDForIP_Call) RunAndReturn(run func(ctx context.Context, ip string) (string, error)) *Client_GetEntityIDForIP_Call {
	_c.Call.Return(run)
	return _c
}

// GetK8sClusterME provides a mock function for the type Client
func (_mock *Client) GetK8sClusterME(ctx context.Context, kubeSystemUUID string) (dynatrace.K8sClusterME, error) {
	ret := _mock.Called(ctx, kubeSystemUUID)

	if len(ret) == 0 {
		panic("no return value specified for GetK8sClusterME")
	}

	var r0 dynatrace.K8sClusterME
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (dynatrace.K8sClusterME, error)); ok {
		return returnFunc(ctx, kubeSystemUUID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) dynatrace.K8sClusterME); ok {
		r0 = returnFunc(ctx, kubeSystemUUID)
	} else {
		r0 = ret.Get(0).(dynatrace.K8sClusterME)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, kubeSystemUUID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetK8sClusterME_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetK8sClusterME'
type Client_GetK8sClusterME_Call struct {
	*mock.Call
}

// GetK8sClusterME is a helper method to define mock.On call
//   - ctx context.Context
//   - kubeSystemUUID string
func (_e *Client_Expecter) GetK8sClusterME(ctx interface{}, kubeSystemUUID interface{}) *Client_GetK8sClusterME_Call {
	return &Client_GetK8sClusterME_Call{Call: _e.mock.On("GetK8sClusterME", ctx, kubeSystemUUID)}
}

func (_c *Client_GetK8sClusterME_Call) Run(run func(ctx context.Context, kubeSystemUUID string)) *Client_GetK8sClusterME_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetK8sClusterME_Call) Return(k8sClusterME dynatrace.K8sClusterME, err error) *Client_GetK8sClusterME_Call {
	_c.Call.Return(k8sClusterME, err)
	return _c
}

func (_c *Client_GetK8sClusterME_Call) RunAndReturn(run func(ctx context.Context, kubeSystemUUID string) (dynatrace.K8sClusterME, error)) *Client_GetK8sClusterME_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestActiveGateImage provides a mock function for the type Client
func (_mock *Client) GetLatestActiveGateImage(ctx context.Context) (*dynatrace.LatestImageInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestActiveGateImage")
	}

	var r0 *dynatrace.LatestImageInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*dynatrace.LatestImageInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *dynatrace.LatestImageInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dynatrace.LatestImageInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetLatestActiveGateImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestActiveGateImage'
type Client_GetLatestActiveGateImage_Call struct {
	*mock.Call
}

// GetLatestActiveGateImage is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetLatestActiveGateImage(ctx interface{}) *Client_GetLatestActiveGateImage_Call {
	return &Client_GetLatestActiveGateImage_Call{Call: _e.mock.On("GetLatestActiveGateImage", ctx)}
}

func (_c *Client_GetLatestActiveGateImage_Call) Run(run func(ctx context.Context)) *Client_GetLatestActiveGateImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetLatestActiveGateImage_Call) Return(latestImageInfo *dynatrace.LatestImageInfo, err error) *Client_GetLatestActiveGateImage_Call {
	_c.Call.Return(latestImageInfo, err)
	return _c
}

func (_c *Client_GetLatestActiveGateImage_Call) RunAndReturn(run func(ctx context.Context) (*dynatrace.LatestImageInfo, error)) *Client_GetLatestActiveGateImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestActiveGateVersion provides a mock function for the type Client
func (_mock *Client) GetLatestActiveGateVersion(ctx context.Context, os string) (string, error) {
	ret := _mock.Called(ctx, os)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestActiveGateVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, os)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, os)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, os)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetLatestActiveGateVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestActiveGateVersion'
type Client_GetLatestActiveGateVersion_Call struct {
	*mock.Call
}

// GetLatestActiveGateVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - os string
func (_e *Client_Expecter) GetLatestActiveGateVersion(ctx interface{}, os interface{}) *Client_GetLatestActiveGateVersion_Call {
	return &Client_GetLatestActiveGateVersion_Call{Call: _e.mock.On("GetLatestActiveGateVersion", ctx, os)}
}

func (_c *Client_GetLatestActiveGateVersion_Call) Run(run func(ctx context.Context, os string)) *Client_GetLatestActiveGateVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetLatestActiveGateVersion_Call) Return(s string, err error) *Client_GetLatestActiveGateVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_GetLatestActiveGateVersion_Call) RunAndReturn(run func(ctx context.Context, os string) (string, error)) *Client_GetLatestActiveGateVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestAgent provides a mock function for the type Client
func (_mock *Client) GetLatestAgent(ctx context.Context, os string, installerType string, flavor string, arch string, technologies []string, skipMetadata bool, writer io.Writer) error {
	ret := _mock.Called(ctx, os, installerType, flavor, arch, technologies, skipMetadata, writer)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestAgent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, bool, io.Writer) error); ok {
		r0 = returnFunc(ctx, os, installerType, flavor, arch, technologies, skipMetadata, writer)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_GetLatestAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestAgent'
type Client_GetLatestAgent_Call struct {
	*mock.Call
}

// GetLatestAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - os string
//   - installerType string
//   - flavor string
//   - arch string
//   - technologies []string
//   - skipMetadata bool
//   - writer io.Writer
func (_e *Client_Expecter) GetLatestAgent(ctx interface{}, os interface{}, installerType interface{}, flavor interface{}, arch interface{}, technologies interface{}, skipMetadata interface{}, writer interface{}) *Client_GetLatestAgent_Call {
	return &Client_GetLatestAgent_Call{Call: _e.mock.On("GetLatestAgent", ctx, os, installerType, flavor, arch, technologies, skipMetadata, writer)}
}

func (_c *Client_GetLatestAgent_Call) Run(run func(ctx context.Context, os string, installerType string, flavor string, arch string, technologies []string, skipMetadata bool, writer io.Writer)) *Client_GetLatestAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 []string
		if args[5] != nil {
			arg5 = args[5].([]string)
		}
		var arg6 bool
		if args[6] != nil {
			arg6 = args[6].(bool)
		}
		var arg7 io.Writer
		if args[7] != nil {
			arg7 = args[7].(io.Writer)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
		)
	})
	return _c
}

func (_c *Client_GetLatestAgent_Call) Return(err error) *Client_GetLatestAgent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_GetLatestAgent_Call) RunAndReturn(run func(ctx context.Context, os string, installerType string, flavor string, arch string, technologies []string, skipMetadata bool, writer io.Writer) error) *Client_GetLatestAgent_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestAgentVersion provides a mock function for the type Client
func (_mock *Client) GetLatestAgentVersion(ctx context.Context, os string, installerType string) (string, error) {
	ret := _mock.Called(ctx, os, installerType)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestAgentVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return returnFunc(ctx, os, installerType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = returnFunc(ctx, os, installerType)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, os, installerType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetLatestAgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestAgentVersion'
type Client_GetLatestAgentVersion_Call struct {
	*mock.Call
}

// GetLatestAgentVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - os string
//   - installerType string
func (_e *Client_Expecter) GetLatestAgentVersion(ctx interface{}, os interface{}, installerType interface{}) *Client_GetLatestAgentVersion_Call {
	return &Client_GetLatestAgentVersion_Call{Call: _e.mock.On("GetLatestAgentVersion", ctx, os, installerType)}
}

func (_c *Client_GetLatestAgentVersion_Call) Run(run func(ctx context.Context, os string, installerType string)) *Client_GetLatestAgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_GetLatestAgentVersion_Call) Return(s string, err error) *Client_GetLatestAgentVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Client_GetLatestAgentVersion_Call) RunAndReturn(run func(ctx context.Context, os string, installerType string) (string, error)) *Client_GetLatestAgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestCodeModulesImage provides a mock function for the type Client
func (_mock *Client) GetLatestCodeModulesImage(ctx context.Context) (*dynatrace.LatestImageInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestCodeModulesImage")
	}

	var r0 *dynatrace.LatestImageInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*dynatrace.LatestImageInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *dynatrace.LatestImageInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dynatrace.LatestImageInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetLatestCodeModulesImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestCodeModulesImage'
type Client_GetLatestCodeModulesImage_Call struct {
	*mock.Call
}

// GetLatestCodeModulesImage is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetLatestCodeModulesImage(ctx interface{}) *Client_GetLatestCodeModulesImage_Call {
	return &Client_GetLatestCodeModulesImage_Call{Call: _e.mock.On("GetLatestCodeModulesImage", ctx)}
}

func (_c *Client_GetLatestCodeModulesImage_Call) Run(run func(ctx context.Context)) *Client_GetLatestCodeModulesImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetLatestCodeModulesImage_Call) Return(latestImageInfo *dynatrace.LatestImageInfo, err error) *Client_GetLatestCodeModulesImage_Call {
	_c.Call.Return(latestImageInfo, err)
	return _c
}

func (_c *Client_GetLatestCodeModulesImage_Call) RunAndReturn(run func(ctx context.Context) (*dynatrace.LatestImageInfo, error)) *Client_GetLatestCodeModulesImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestOneAgentImage provides a mock function for the type Client
func (_mock *Client) GetLatestOneAgentImage(ctx context.Context) (*dynatrace.LatestImageInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestOneAgentImage")
	}

	var r0 *dynatrace.LatestImageInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*dynatrace.LatestImageInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *dynatrace.LatestImageInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dynatrace.LatestImageInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetLatestOneAgentImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestOneAgentImage'
type Client_GetLatestOneAgentImage_Call struct {
	*mock.Call
}

// GetLatestOneAgentImage is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetLatestOneAgentImage(ctx interface{}) *Client_GetLatestOneAgentImage_Call {
	return &Client_GetLatestOneAgentImage_Call{Call: _e.mock.On("GetLatestOneAgentImage", ctx)}
}

func (_c *Client_GetLatestOneAgentImage_Call) Run(run func(ctx context.Context)) *Client_GetLatestOneAgentImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetLatestOneAgentImage_Call) Return(latestImageInfo *dynatrace.LatestImageInfo, err error) *Client_GetLatestOneAgentImage_Call {
	_c.Call.Return(latestImageInfo, err)
	return _c
}

func (_c *Client_GetLatestOneAgentImage_Call) RunAndReturn(run func(ctx context.Context) (*dynatrace.LatestImageInfo, error)) *Client_GetLatestOneAgentImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetOneAgentConnectionInfo provides a mock function for the type Client
func (_mock *Client) GetOneAgentConnectionInfo(ctx context.Context) (dynatrace.OneAgentConnectionInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetOneAgentConnectionInfo")
	}

	var r0 dynatrace.OneAgentConnectionInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (dynatrace.OneAgentConnectionInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) dynatrace.OneAgentConnectionInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(dynatrace.OneAgentConnectionInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetOneAgentConnectionInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOneAgentConnectionInfo'
type Client_GetOneAgentConnectionInfo_Call struct {
	*mock.Call
}

// GetOneAgentConnectionInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetOneAgentConnectionInfo(ctx interface{}) *Client_GetOneAgentConnectionInfo_Call {
	return &Client_GetOneAgentConnectionInfo_Call{Call: _e.mock.On("GetOneAgentConnectionInfo", ctx)}
}

func (_c *Client_GetOneAgentConnectionInfo_Call) Run(run func(ctx context.Context)) *Client_GetOneAgentConnectionInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetOneAgentConnectionInfo_Call) Return(oneAgentConnectionInfo dynatrace.OneAgentConnectionInfo, err error) *Client_GetOneAgentConnectionInfo_Call {
	_c.Call.Return(oneAgentConnectionInfo, err)
	return _c
}

func (_c *Client_GetOneAgentConnectionInfo_Call) RunAndReturn(run func(ctx context.Context) (dynatrace.OneAgentConnectionInfo, error)) *Client_GetOneAgentConnectionInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessModuleConfig provides a mock function for the type Client
func (_mock *Client) GetProcessModuleConfig(ctx context.Context, prevRevision uint) (*dynatrace.ProcessModuleConfig, error) {
	ret := _mock.Called(ctx, prevRevision)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessModuleConfig")
	}

	var r0 *dynatrace.ProcessModuleConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) (*dynatrace.ProcessModuleConfig, error)); ok {
		return returnFunc(ctx, prevRevision)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) *dynatrace.ProcessModuleConfig); ok {
		r0 = returnFunc(ctx, prevRevision)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dynatrace.ProcessModuleConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(ctx, prevRevision)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetProcessModuleConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessModuleConfig'
type Client_GetProcessModuleConfig_Call struct {
	*mock.Call
}

// GetProcessModuleConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - prevRevision uint
func (_e *Client_Expecter) GetProcessModuleConfig(ctx interface{}, prevRevision interface{}) *Client_GetProcessModuleConfig_Call {
	return &Client_GetProcessModuleConfig_Call{Call: _e.mock.On("GetProcessModuleConfig", ctx, prevRevision)}
}

func (_c *Client_GetProcessModuleConfig_Call) Run(run func(ctx context.Context, prevRevision uint)) *Client_GetProcessModuleConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetProcessModuleConfig_Call) Return(processModuleConfig *dynatrace.ProcessModuleConfig, err error) *Client_GetProcessModuleConfig_Call {
	_c.Call.Return(processModuleConfig, err)
	return _c
}

func (_c *Client_GetProcessModuleConfig_Call) RunAndReturn(run func(ctx context.Context, prevRevision uint) (*dynatrace.ProcessModuleConfig, error)) *Client_GetProcessModuleConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetRulesSettings provides a mock function for the type Client
func (_mock *Client) GetRulesSettings(ctx context.Context, kubeSystemUUID string, entityID string) (dynatrace.GetRulesSettingsResponse, error) {
	ret := _mock.Called(ctx, kubeSystemUUID, entityID)

	if len(ret) == 0 {
		panic("no return value specified for GetRulesSettings")
	}

	var r0 dynatrace.GetRulesSettingsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (dynatrace.GetRulesSettingsResponse, error)); ok {
		return returnFunc(ctx, kubeSystemUUID, entityID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) dynatrace.GetRulesSettingsResponse); ok {
		r0 = returnFunc(ctx, kubeSystemUUID, entityID)
	} else {
		r0 = ret.Get(0).(dynatrace.GetRulesSettingsResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, kubeSystemUUID, entityID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetRulesSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRulesSettings'
type Client_GetRulesSettings_Call struct {
	*mock.Call
}

// GetRulesSettings is a helper method to define mock.On call
//   - ctx context.Context
//   - kubeSystemUUID string
//   - entityID string
func (_e *Client_Expecter) GetRulesSettings(ctx interface{}, kubeSystemUUID interface{}, entityID interface{}) *Client_GetRulesSettings_Call {
	return &Client_GetRulesSettings_Call{Call: _e.mock.On("GetRulesSettings", ctx, kubeSystemUUID, entityID)}
}

func (_c *Client_GetRulesSettings_Call) Run(run func(ctx context.Context, kubeSystemUUID string, entityID string)) *Client_GetRulesSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_GetRulesSettings_Call) Return(getRulesSettingsResponse dynatrace.GetRulesSettingsResponse, err error) *Client_GetRulesSettings_Call {
	_c.Call.Return(getRulesSettingsResponse, err)
	return _c
}

func (_c *Client_GetRulesSettings_Call) RunAndReturn(run func(ctx context.Context, kubeSystemUUID string, entityID string) (dynatrace.GetRulesSettingsResponse, error)) *Client_GetRulesSettings_Call {
	_c.Call.Return(run)
	return _c
}

// GetSettingsForLogModule provides a mock function for the type Client
func (_mock *Client) GetSettingsForLogModule(ctx context.Context, monitoredEntity string) (dynatrace.GetLogMonSettingsResponse, error) {
	ret := _mock.Called(ctx, monitoredEntity)

	if len(ret) == 0 {
		panic("no return value specified for GetSettingsForLogModule")
	}

	var r0 dynatrace.GetLogMonSettingsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (dynatrace.GetLogMonSettingsResponse, error)); ok {
		return returnFunc(ctx, monitoredEntity)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) dynatrace.GetLogMonSettingsResponse); ok {
		r0 = returnFunc(ctx, monitoredEntity)
	} else {
		r0 = ret.Get(0).(dynatrace.GetLogMonSettingsResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, monitoredEntity)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetSettingsForLogModule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSettingsForLogModule'
type Client_GetSettingsForLogModule_Call struct {
	*mock.Call
}

// GetSettingsForLogModule is a helper method to define mock.On call
//   - ctx context.Context
//   - monitoredEntity string
func (_e *Client_Expecter) GetSettingsForLogModule(ctx interface{}, monitoredEntity interface{}) *Client_GetSettingsForLogModule_Call {
	return &Client_GetSettingsForLogModule_Call{Call: _e.mock.On("GetSettingsForLogModule", ctx, monitoredEntity)}
}

func (_c *Client_GetSettingsForLogModule_Call) Run(run func(ctx context.Context, monitoredEntity string)) *Client_GetSettingsForLogModule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetSettingsForLogModule_Call) Return(getLogMonSettingsResponse dynatrace.GetLogMonSettingsResponse, err error) *Client_GetSettingsForLogModule_Call {
	_c.Call.Return(getLogMonSettingsResponse, err)
	return _c
}

func (_c *Client_GetSettingsForLogModule_Call) RunAndReturn(run func(ctx context.Context, monitoredEntity string) (dynatrace.GetLogMonSettingsResponse, error)) *Client_GetSettingsForLogModule_Call {
	_c.Call.Return(run)
	return _c
}

// GetSettingsForMonitoredEntity provides a mock function for the type Client
func (_mock *Client) GetSettingsForMonitoredEntity(ctx context.Context, monitoredEntity dynatrace.K8sClusterME, schemaID string) (dynatrace.GetSettingsResponse, error) {
	ret := _mock.Called(ctx, monitoredEntity, schemaID)

	if len(ret) == 0 {
		panic("no return value specified for GetSettingsForMonitoredEntity")
	}

	var r0 dynatrace.GetSettingsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dynatrace.K8sClusterME, string) (dynatrace.GetSettingsResponse, error)); ok {
		return returnFunc(ctx, monitoredEntity, schemaID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dynatrace.K8sClusterME, string) dynatrace.GetSettingsResponse); ok {
		r0 = returnFunc(ctx, monitoredEntity, schemaID)
	} else {
		r0 = ret.Get(0).(dynatrace.GetSettingsResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dynatrace.K8sClusterME, string) error); ok {
		r1 = returnFunc(ctx, monitoredEntity, schemaID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetSettingsForMonitoredEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSettingsForMonitoredEntity'
type Client_GetSettingsForMonitoredEntity_Call struct {
	*mock.Call
}

// GetSettingsForMonitoredEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - monitoredEntity dynatrace.K8sClusterME
//   - schemaID string
func (_e *Client_Expecter) GetSettingsForMonitoredEntity(ctx interface{}, monitoredEntity interface{}, schemaID interface{}) *Client_GetSettingsForMonitoredEntity_Call {
	return &Client_GetSettingsForMonitoredEntity_Call{Call: _e.mock.On("GetSettingsForMonitoredEntity", ctx, monitoredEntity, schemaID)}
}

func (_c *Client_GetSettingsForMonitoredEntity_Call) Run(run func(ctx context.Context, monitoredEntity dynatrace.K8sClusterME, schemaID string)) *Client_GetSettingsForMonitoredEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 dynatrace.K8sClusterME
		if args[1] != nil {
			arg1 = args[1].(dynatrace.K8sClusterME)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_GetSettingsForMonitoredEntity_Call) Return(getSettingsResponse dynatrace.GetSettingsResponse, err error) *Client_GetSettingsForMonitoredEntity_Call {
	_c.Call.Return(getSettingsResponse, err)
	return _c
}

func (_c *Client_GetSettingsForMonitoredEntity_Call) RunAndReturn(run func(ctx context.Context, monitoredEntity dynatrace.K8sClusterME, schemaID string) (dynatrace.GetSettingsResponse, error)) *Client_GetSettingsForMonitoredEntity_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenScopes provides a mock function for the type Client
func (_mock *Client) GetTokenScopes(ctx context.Context, token string) (dynatrace.TokenScopes, error) {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenScopes")
	}

	var r0 dynatrace.TokenScopes
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (dynatrace.TokenScopes, error)); ok {
		return returnFunc(ctx, token)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) dynatrace.TokenScopes); ok {
		r0 = returnFunc(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dynatrace.TokenScopes)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetTokenScopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenScopes'
type Client_GetTokenScopes_Call struct {
	*mock.Call
}

// GetTokenScopes is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *Client_Expecter) GetTokenScopes(ctx interface{}, token interface{}) *Client_GetTokenScopes_Call {
	return &Client_GetTokenScopes_Call{Call: _e.mock.On("GetTokenScopes", ctx, token)}
}

func (_c *Client_GetTokenScopes_Call) Run(run func(ctx context.Context, token string)) *Client_GetTokenScopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetTokenScopes_Call) Return(tokenScopes dynatrace.TokenScopes, err error) *Client_GetTokenScopes_Call {
	_c.Call.Return(tokenScopes, err)
	return _c
}

func (_c *Client_GetTokenScopes_Call) RunAndReturn(run func(ctx context.Context, token string) (dynatrace.TokenScopes, error)) *Client_GetTokenScopes_Call {
	_c.Call.Return(run)
	return _c
}

// SendEvent provides a mock function for the type Client
func (_mock *Client) SendEvent(ctx context.Context, eventData *dynatrace.EventData) error {
	ret := _mock.Called(ctx, eventData)

	if len(ret) == 0 {
		panic("no return value specified for SendEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dynatrace.EventData) error); ok {
		r0 = returnFunc(ctx, eventData)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_SendEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendEvent'
type Client_SendEvent_Call struct {
	*mock.Call
}

// SendEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventData *dynatrace.EventData
func (_e *Client_Expecter) SendEvent(ctx interface{}, eventData interface{}) *Client_SendEvent_Call {
	return &Client_SendEvent_Call{Call: _e.mock.On("SendEvent", ctx, eventData)}
}

func (_c *Client_SendEvent_Call) Run(run func(ctx context.Context, eventData *dynatrace.EventData)) *Client_SendEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dynatrace.EventData
		if args[1] != nil {
			arg1 = args[1].(*dynatrace.EventData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_SendEvent_Call) Return(err error) *Client_SendEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_SendEvent_Call) RunAndReturn(run func(ctx context.Context, eventData *dynatrace.EventData) error) *Client_SendEvent_Call {
	_c.Call.Return(run)
	return _c
}
